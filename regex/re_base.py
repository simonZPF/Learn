# encoding:utf-8

import re
"""
\b 单词的开头或结尾，也就是单词的分界
\w 匹配字母或数字或下划线或汉字
\s 任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等
\d 数字
.  除了换行符以外的任意字符

^	匹配字符串的开始
$	匹配字符串的结束
*  它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配
+  匹配重复1次或更多次。
{n}	    重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次

字符类
[aeiou] 就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。
[0-9] 代表的含意与\d就是完全一致的

分枝条件
0\d{2}-\d{8}|0\d{3}-\d{7}   匹配两种以连字号分隔的电话号码：
一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

分组
(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次

反义
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符

捕获
(exp)	        匹配exp,并捕获文本到自动命名的组里
(?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp)	        匹配exp,不捕获匹配的文本，也不给此分组分配组号
  \1              代表分组1匹配的文本
零宽断言
(?=exp)    	 匹配exp前面的位置
    b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)
    如查找I'm singing while you're dancing.时，它会匹配sing和danc。
(?<=exp)	 匹配exp后面的位置
    ?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)
    例如在查找reading a book时，它匹配ading。
    (?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。
(?!exp)	     匹配后面跟的不是exp的位置
    \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词 如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错
    \b\w*q(?!u)\w*\b
(?<!exp)	 匹配前面不是exp的位置
注释
(?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

贪婪与懒惰
a.*b，它将会匹配最长的以a开始，以b结束的字符串
如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
a.*?b匹配最短的，以a开始，以b结束的字符串
*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复

"""
# m= re.search(r"\bhi\b","history hi ")#\bX\b精确查找单词
# print m.start()
# m=re.search(r"\bhi(\b.*\b)lucy\b","sdfe as hi sdf sdf w tqa lucy")
# print m.group(1)

# m=re.search(r"0(\d{2})-(\d{8})","023-45681585684684")
# print m.group(1)，m.group(2) #不能匹配到正确的电话

# m=re.search(r"0(\d{2})-(\d{8}$)","023-45681585684684")
# print m==None
# m=re.search(r"^\d{5,12}$","15661")
# print m==None

# m=re.search(r"^\w+","  adfsd") # ^\w+匹配一行的第一个单词
# print m==None